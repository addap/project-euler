;#lang racket
;(provide enumerate-interval)
;(provide square)
;(provide flatmap)
;(provide accumulate)

(define (enumerate-interval a b)
  (define (helper b_ result)
    (if (< b_ a)
      result
      (helper (- b_ 1) (cons b_ result))))
  (helper b '()))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (flatmap proc set)
  (accumulate append '() (map proc set)))

(define (timed-procedure-call proc)
  (let ((start-time (runtime)))
    (proc)
    (display "*** ") (display (- (runtime) start-time))))

(define (make-tree)
  (let ((data (cons '() (cons '() '()))))
    (define (entry)
      (car data))
    (define (left-child)
      (cadr data))
    (define (right-child)
      (cddr data))
    ;; (define (set-entry entry)
    ;;   (set-car! data entry))
    (define (print)
      (display "entry: ")
      (display (car data))
      (newline)
      (display "children:")
      (newline)
      (for-each (lambda (x)
		  (if (not (null? x))
		      (x 'print)
		      (newline))) (cdr data)))
    (define (dispatch m)
      (cond ((eq? m 'print) (print))
	    ((eq? m 'entry) (entry))
	    ((eq? m 'children) (children))
	    ((eq? m 'add-child) add-child)
	    ((eq? m 'set-entry) set-entry)
	    (else (display "error"))))
    dispatch))
